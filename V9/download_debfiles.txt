#!/bin/bash

# HAProxy and Keepalived Offline Package Downloader
# This script downloads all .deb files needed to install HAProxy and Keepalived
# in an air-gapped environment

set -euo pipefail

# Configuration
DOWNLOAD_DIR="./offline_packages"
PACKAGES=("haproxy" "keepalived")
TEMP_DIR="/tmp/apt-download-$$"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging function
log() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Check if running as root or with sudo
check_privileges() {
    if [[ $EUID -ne 0 ]]; then
        error "This script needs to be run as root or with sudo"
        error "Usage: sudo $0"
        exit 1
    fi
}

# Check if required tools are available
check_dependencies() {
    local missing_tools=()
    
    for tool in apt-get apt-cache dpkg; do
        if ! command -v "$tool" &> /dev/null; then
            missing_tools+=("$tool")
        fi
    done
    
    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        error "Missing required tools: ${missing_tools[*]}"
        error "This script requires a Debian/Ubuntu system with apt package manager"
        exit 1
    fi
}

# Update package lists
update_package_lists() {
    log "Updating package lists..."
    if apt-get update > /dev/null 2>&1; then
        success "Package lists updated successfully"
    else
        error "Failed to update package lists"
        exit 1
    fi
}

# Create directories
setup_directories() {
    log "Setting up directories..."
    
    # Create download directory
    mkdir -p "$DOWNLOAD_DIR"
    
    # Create temporary directory
    mkdir -p "$TEMP_DIR"
    
    success "Directories created: $DOWNLOAD_DIR"
}

# Get package dependencies recursively
get_all_dependencies() {
    local package="$1"
    local deps_file="$TEMP_DIR/${package}_deps.txt"
    
    log "Resolving dependencies for $package..."
    
    # Get dependencies using apt-cache
    apt-cache depends "$package" 2>/dev/null | \
        grep -E "^\s*(Depends|PreDepends):" | \
        awk '{print $2}' | \
        sed 's/[<>].*//g' | \
        sort -u > "$deps_file"
    
    # Get recursive dependencies
    local all_deps="$TEMP_DIR/all_deps_${package}.txt"
    echo "$package" > "$all_deps"
    
    while IFS= read -r dep; do
        if [[ -n "$dep" && "$dep" != "$package" ]]; then
            # Skip virtual packages and packages that don't exist
            if apt-cache show "$dep" &>/dev/null; then
                echo "$dep" >> "$all_deps"
                # Get dependencies of dependencies (limited depth to avoid infinite loops)
                apt-cache depends "$dep" 2>/dev/null | \
                    grep -E "^\s*(Depends|PreDepends):" | \
                    awk '{print $2}' | \
                    sed 's/[<>].*//g' | \
                    while IFS= read -r subdep; do
                        if [[ -n "$subdep" ]] && apt-cache show "$subdep" &>/dev/null; then
                            echo "$subdep" >> "$all_deps"
                        fi
                    done
            fi
        fi
    done < "$deps_file"
    
    # Remove duplicates and sort
    sort -u "$all_deps" -o "$all_deps"
    
    local dep_count
    dep_count=$(wc -l < "$all_deps")
    success "Found $dep_count packages for $package (including dependencies)"
}

# Download packages
download_packages() {
    local package="$1"
    local all_deps="$TEMP_DIR/all_deps_${package}.txt"
    
    log "Downloading packages for $package..."
    
    # Change to download directory
    cd "$DOWNLOAD_DIR"
    
    # Download packages without installing
    local download_count=0
    local failed_count=0
    
    while IFS= read -r pkg; do
        if [[ -n "$pkg" ]]; then
            log "Downloading $pkg..."
            if apt-get download "$pkg" 2>/dev/null; then
                ((download_count++))
            else
                warning "Failed to download $pkg (may be virtual package or already satisfied)"
                ((failed_count++))
            fi
        fi
    done < "$all_deps"
    
    success "Downloaded $download_count packages for $package"
    if [[ $failed_count -gt 0 ]]; then
        warning "$failed_count packages failed to download"
    fi
    
    cd - > /dev/null
}

# Generate installation script
generate_install_script() {
    local install_script="$DOWNLOAD_DIR/install_packages.sh"
    
    log "Generating installation script..."
    
    cat > "$install_script" << 'EOF'
#!/bin/bash

# Offline Installation Script for HAProxy and Keepalived
# Generated by offline package downloader

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# Check if running as root
if [[ $EUID -ne 0 ]]; then
    error "This script needs to be run as root or with sudo"
    exit 1
fi

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

log "Installing packages from $SCRIPT_DIR..."

# Install all .deb files
if ls "$SCRIPT_DIR"/*.deb 1> /dev/null 2>&1; then
    log "Installing .deb packages..."
    if dpkg -i "$SCRIPT_DIR"/*.deb; then
        success "All packages installed successfully"
    else
        error "Some packages failed to install, attempting to fix dependencies..."
        apt-get install -f -y
        success "Dependencies fixed"
    fi
else
    error "No .deb files found in $SCRIPT_DIR"
    exit 1
fi

# Verify installations
log "Verifying installations..."

if command -v haproxy &> /dev/null; then
    success "HAProxy installed successfully"
    haproxy -v
else
    error "HAProxy installation failed"
fi

if command -v keepalived &> /dev/null; then
    success "Keepalived installed successfully"
    keepalived --version
else
    error "Keepalived installation failed"
fi

log "Installation complete!"
EOF

    chmod +x "$install_script"
    success "Installation script created: $install_script"
}

# Generate package list
generate_package_list() {
    local package_list="$DOWNLOAD_DIR/package_list.txt"
    
    log "Generating package list..."
    
    echo "# Package List - Generated on $(date)" > "$package_list"
    echo "# Downloaded packages for HAProxy and Keepalived offline installation" >> "$package_list"
    echo "" >> "$package_list"
    
    cd "$DOWNLOAD_DIR"
    if ls *.deb 1> /dev/null 2>&1; then
        for deb_file in *.deb; do
            local pkg_info
            pkg_info=$(dpkg-deb -I "$deb_file" | grep -E "^\s*Package:|^\s*Version:|^\s*Architecture:" | tr '\n' ' ')
            echo "$deb_file - $pkg_info" >> "$package_list"
        done
    fi
    cd - > /dev/null
    
    success "Package list created: $package_list"
}

# Cleanup function
cleanup() {
    log "Cleaning up temporary files..."
    rm -rf "$TEMP_DIR"
}

# Main execution
main() {
    log "Starting HAProxy and Keepalived offline package downloader..."
    
    # Setup trap for cleanup
    trap cleanup EXIT
    
    # Run checks
    check_privileges
    check_dependencies
    
    # Setup
    update_package_lists
    setup_directories
    
    # Process each package
    for package in "${PACKAGES[@]}"; do
        log "Processing $package..."
        get_all_dependencies "$package"
        download_packages "$package"
    done
    
    # Remove duplicate .deb files
    cd "$DOWNLOAD_DIR"
    if ls *.deb 1> /dev/null 2>&1; then
        log "Removing duplicate packages..."
        # Keep only the latest version of each package
        for pkg in $(ls *.deb | sed 's/_.*//g' | sort -u); do
            ls ${pkg}_*.deb | sort -V | head -n -1 | xargs -r rm -f
        done
    fi
    cd - > /dev/null
    
    # Generate additional files
    generate_install_script
    generate_package_list
    
    # Summary
    local total_packages
    total_packages=$(ls "$DOWNLOAD_DIR"/*.deb 2>/dev/null | wc -l)
    local total_size
    total_size=$(du -sh "$DOWNLOAD_DIR" | cut -f1)
    
    success "Download completed successfully!"
    echo ""
    echo "Summary:"
    echo "  - Total packages downloaded: $total_packages"
    echo "  - Total size: $total_size"
    echo "  - Download directory: $DOWNLOAD_DIR"
    echo ""
    echo "To install on air-gapped system:"
    echo "  1. Copy the entire '$DOWNLOAD_DIR' directory to the target system"
    echo "  2. Run: sudo $DOWNLOAD_DIR/install_packages.sh"
}

# Run main function
main "$@"
